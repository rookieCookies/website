<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Voxel Engine in a Weekend – daymare.net</title>
    <link rel="stylesheet" href="../../blog_styles.css">
    <link rel="preload" as="image" href="./thumbnail.png">
    <script type="application/ld+json">
        {
            "@context": "https://schema.org",
            "@type": "BlogPosting",
            "headline": "Voxel Engine in a Weekend",
            "image": "https://daymare.net/blogs/voxelling-in-a-weekend/thumbnail.png",
            "author": {
                "@type": "Person",
                "name": "Todaymare"
            },
            "publisher": {
                "@type": "Organization",
                "name": "daymare.net",
                "logo": {
                "@type": "ImageObject",
                "url": "https://daymare.net/logo.png"
                }
            },
            "datePublished": "2025-10-05T14:37:02.344888587Z",
            "url": "https://daymare.net/blogs/voxelling-in-a-weekend/",
            "description": "todo"
        }
    </script>
    <script defer data-domain="daymare.net" src="https://plausible.io/js/script.js"></script>
</head>
<body>
    <div class="text-body">

    <meta name="description" content="todo">
    <meta name="author" content="Todaymare">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta property="og:title" content="Voxel Engine in a Weekend">
    <meta property="og:description" content="todo">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://daymare.net/blogs/voxelling-in-a-weekend/">
    <meta property="og:image" content="https://daymare.net/blogs/voxelling-in-a-weekend/thumbnail.png">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Voxel Engine in a Weekend">
    <meta name="twitter:description" content="todo">
    <meta name="twitter:image" content="https://daymare.net/blogs/voxelling-in-a-weekend/thumbnail.png">

    <link rel="canonical" href="https://daymare.net/blogs/voxelling-in-a-weekend/">


    <div class="meta" itemscope itemtype="https://schema.org/BlogPosting">
        <span><time itemprop="datePublished" datetime="2025-10-05T14:37:02.344888587Z">Oct 5</time> | <span itemprop="author">by me</span></span>
        <span class="read-time">3 min. read</span>
    </div>
    

    <img loading="eager" class="thumbnail" src="./thumbnail.png" alt="Thumbnail for Voxel Engine in a Weekend blog post" />

    <header>
        <h1>Voxel Engine in a Weekend</h1>
    </header>

    <main>
        <article>
            <p>todo</p>
<h2>1. Overview</h2>
<p>Hi, so you want to make a voxel engine? Me too!</p>
<p>This will be our little weekend project where we go from a blank file to a voxel world you can walk around and interact with.</p>
<p>I'll be using Rust, but everything here should make sense no matter what language you're into. The focus isn't on the code but on the systems that come together to create a voxel engine.</p>
<h2>2. Making a window</h2>
<p>Okay, so first we need to create a window. There’s a bunch of ways to do this, but since we’ll be using OpenGL later, I’ll go with GLFW – it’s kind of the classic combo.</p>
<p>note: I won't be explaining every line of set-up code but if you need a more comprehensive guide on how to get everything ready you might want to check out <a href="https://learnopengl.com/Getting-started/Creating-a-window">LearnOpenGL</a></p>
<p>First we'll need to initialize GLFW</p>
<pre><code class="language-rust">fn main() {
    unsafe {

    glfwInit();

    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);

    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    // if you're on a mac
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, 1);

    }
}
</code></pre>
<p>and then create a window</p>
<pre><code class="language-rust">    ...
    let window = glfwCreateWindow(
        1920,
        1080,
        c&quot;voxel engine&quot;.as_ptr(),
        null_mut(),
        null_mut()
    );

    if window.is_null() {
        println!(&quot;failed to create GLFW window&quot;);
        return;
    }

    glfwMakeContextCurrent(window);
    ...
</code></pre>
<p>We'll also have to load the OpenGL functions, though how you do this might be very different based on the language you're using</p>
<pre><code class="language-rust">    ...
    gl::load_with(|s| {
        let cstr = CString::new(s).unwrap();
        let result = glfwGetProcAddress(cstr.as_ptr());

        if result.is_null() {
            println!(&quot;failed to load gl function '{s}'&quot;);
        }

        result
    });
    ...
</code></pre>
<p>now we can just create an infinite loop and we will have our window!</p>
<pre><code>    ...
    loop {
        glfwPollEvents();
    }
    ...
</code></pre>
<p>note: in Rust the <code>loop</code> keyword creates an infinite loop. basically the same as <code>while true</code></p>
<h1>3. Hello Triangle</h1>
<p>I know, I know. Basically every graphics tutorial starts with these two but there's a good reason for it. I promise it won't take too long but we do need to do it in order to ensure we have our pipeline set up properly</p>
<p>Let's start with moving all of our set-up into a <code>Renderer</code> class.</p>
<pre><code class="language-rust">
struct Renderer {
    window: *mut glfw::Window,
}


impl Renderer {
    pub fn new() {
        unsafe {

        glfwInit();

        glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
        glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);

        glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
        glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, 1);

        let window = glfwCreateWindow(
            1920,
            1080,
            c&quot;voxel engine&quot;.as_ptr(),
            null_mut(),
            null_mut()
        );


        if window.is_null() {
            println!(&quot;failed to create GLFW window&quot;);
            return;
        }

        glfwMakeContextCurrent(window);

        
        gl::load_with(|s| {
            let cstr = CString::new(s).unwrap();
            let result = glfwGetProcAddress(cstr.as_ptr());

            if result.is_none() {
                println!(&quot;failed to load gl function '{s}'&quot;);
            }

            result.map(|x| x as _).unwrap_or(null())
        });

        }
    }
}
</code></pre>
<p>after that we can create some simple <code>begin</code> and <code>end</code> frame functions on the renderer</p>
<pre><code class="language-rust">    pub fn begin_frame(&amp;mut self) {
        unsafe {

        gl::ClearColor(1.0, 1.0, 1.0, 1.0);
        
        }
    }


    pub fn end_frame(&amp;mut self) {
        unsafe {

        glfwSwapBuffers(self.window);
        glfwPollEvents();
        
        }
    }

</code></pre>
<p><img src="assets/blank_window.png" alt="blank window" /></p>
<ol>
<li>Making a window</li>
<li>Hello triangle</li>
<li>Adding a camera</li>
<li>Adding a cube</li>
<li>Chunks
5.1) Meshing a chunk
5.2) Optimizing the mesh</li>
<li>Chunk management</li>
<li>Block types
7.1) Textures</li>
<li>Physics (we'll go with simple aabb checks</li>
<li>Interacting with the world</li>
<li>Saving &amp; loading the world</li>
<li>challenges for the reader maybe
am i qualiifed to even make a post like this.. damn</li>
</ol>
        </article>
    </main>

    <nav class="post-nav">
        <a class="home" href="../../">Home</a>
    </nav>
    </div>
    <script async src="https://scripts.simpleanalyticscdn.com/latest.js"></script>
</body>
</html>
