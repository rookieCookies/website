<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>daymare.net</title><id>https://daymare.net/</id><updated>2025-11-01T14:59:19.741090+00:00</updated><author><name>daymare</name><uri>https://daymare.net/</uri></author><link href="https://daymare.net/" rel="self"/><entry><title>This week in margarine</title><id>https://daymare.net/blogs/this-week-in-margarine</id><updated>2025-10-26T06:46:11.276630437+00:00</updated><author><name>daymare</name><uri>https://daymare.net/</uri></author><category term="Blog"/><link href="https://daymare.net/blogs/this-week-in-margarine" rel="alternate"/><published>2025-10-26T06:46:11.276630437+00:00</published><summary>&lt;p&gt;A quick update on the progress of my programming language margarine. It&apos;s build system, why it won&apos;t have a JIT, and other design decisions.&lt;/p&gt;</summary><content type="html">&lt;p&gt;A quick update on the progress of my programming language margarine. It&apos;s build system, why it won&apos;t have a JIT, and other design decisions.&lt;/p&gt;
&lt;p&gt;For those who don&apos;t know margarine, it&apos;s my programming language that&apos;s meant to be a replacement for Lua in my own projects, &lt;a href=&quot;../four-years-five-failures-one-compiler/&quot;&gt;check out this post&lt;/a&gt; if you want to learn more about it.&lt;/p&gt;
&lt;p&gt;Hello! So here&apos;s the thing, this week I decided that I wanted to be done with margarine as soon as possible.
But I&apos;m also quite tired of having way too many unfinished projects, so I had to decide on a to-do list that I needed to finish before I could call margarine done. And before you click off, a JIT was in this to-do list until yesterday.&lt;/p&gt;
&lt;p&gt;Here, I&apos;ll show you the to-do list.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a basic JIT&lt;/li&gt;
&lt;li&gt;finishing up the build system&lt;/li&gt;
&lt;li&gt;a GC&lt;/li&gt;
&lt;li&gt;some bug fixes&lt;/li&gt;
&lt;li&gt;stdlib&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So me being me I went with the one I have never done before, the JIT.&lt;/p&gt;
&lt;h2&gt;The JIT&lt;/h2&gt;
&lt;p&gt;In a previous version of margarine I had used LLVM¹ to compile to native code and as far as I remember it was a horrible experience. Heck when I went back to margarine it didn&apos;t even compile even though literally nothing about my build system had changed.&lt;/p&gt;
&lt;p&gt;So this time I decided to use something easier, something shinier, something newer, something called &lt;a href=&quot;https://cranelift.dev/&quot;&gt;Cranelift&lt;/a&gt;. Which claims to be faster than LLVM while admitting that it has less optimisations. That sounds like a good trade-off, right? It probably doesn&apos;t have many of the niche optimisations that LLVM has built up over the years but it has the important optimisations, right?&lt;/p&gt;
&lt;p&gt;That sounded amazing! Not only did it mean that I didn&apos;t need to deal with LLVM&apos;s jankness but also that the JIT will compile code faster!&lt;/p&gt;
&lt;p&gt;Now, I don&apos;t need margarine&apos;s JIT to be perfect or even optimized. I just want to add a JIT to the runtime to make it faster and I want to get it over with quickly so I could move onto the next thing in the to-do list. So I just made the JIT convert my interpreter one-to-one.&lt;/p&gt;
&lt;p&gt;I think this&apos;ll make more sense if I showed some code, so let&apos;s take the &lt;code&gt;AddInt&lt;/code&gt; instruction. (fyi, margarine&apos;s interpreter is a stack based interpreter)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rs&quot;&gt;AddInt =&amp;gt; {
   let rhs = stack.pop().as_int();
   let lhs = stack.pop().as_int();
   stack.push(Value::Int(lhs + rhs))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and so the JIT would just do that exact same thing but inlined. Which made the JIT the same as the interpreter except without the instruction over-head and any optimisations Cranelift could apply along-side it.&lt;/p&gt;
&lt;p&gt;Now this meant that the JIT would often generate redundant loads and stores, stuff like store x then immediately override x. Which was fine, I thought. It sounds like a basic optimisation, surely Cranelift wouldn&apos;t even break a sweat, right?&lt;/p&gt;
&lt;p&gt;Other than the fact that this isn&apos;t much of a basic optimisation, Cranelift doesn&apos;t even try to do anything about it. So I was left on my own.&lt;/p&gt;
&lt;p&gt;Is this an unsolvable problem? No.
Is there nothing I can do about it? Certainly not.
Is this a problem I wanted to have when I decided to JIT? No, but it is what it is.&lt;/p&gt;
&lt;p&gt;So I got onto brainstorming how I could go about solving this.
For one, I could switch to a register based VM which would immediately eliminate any interaction with the stack since I can just use cranelift variables. But this would probably require me to rewrite my entire VM and some form of register-allocation would be practically necessary to keep the register count under 256 (one byte).&lt;/p&gt;
&lt;p&gt;Or I could convert the stack into cranelift variables at runtime, though that would require me to know the stack height at any given instruction. The idea would be to convert each stack slot to a Cranelift variable and simulate push &amp;amp; pops.&lt;/p&gt;
&lt;p&gt;There&apos;s many ways I could make this JIT thing work, but after talking to people I&apos;m not sure if it&apos;s even worth it. Sure, it&apos;d make things faster but there&apos;s a lot more I should be focusing on right now (many things that when implemented would probably require the JIT to be reworked anyways).&lt;/p&gt;
&lt;p&gt;So I moved onto the next item on the list.&lt;/p&gt;
&lt;p&gt;¹: Writing this some part of me wishes I never ditched compiling to native code. I know it was the right decision but the &lt;em&gt;speed&lt;/em&gt; is very alluring especially now that I don&apos;t even have a JIT. Woman in the red dress or something I dunno.&lt;/p&gt;
&lt;h2&gt;The build system&lt;/h2&gt;
&lt;p&gt;This part of margarine has gone through a few iterations already. At the start, I just had to specify every single file I wanted to include in the CLI tool, which led to commands like&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;margarine std std/duration std/list std/rand raylib raylib/keys raylib/window flappy_bird
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This ability to be extremely granular on what files to import was a design decision that I wanted to preserve since margarine is meant to be an embeddable language. But of course, we also need margarine to stand on its own, so I had to figure out something else.&lt;/p&gt;
&lt;p&gt;The first thing I tried was to just copy Rust. I had a &lt;code&gt;build.toml&lt;/code&gt; file where you could specify your dependencies, and your code would be in a &lt;code&gt;src/&lt;/code&gt; directory with the entry point being a function named &lt;code&gt;main&lt;/code&gt; in &lt;code&gt;src/main.mar&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This worked for a bit; the CLI tool would fetch the github repos of the dependencies, cache them in an &lt;code&gt;artifacts/&lt;/code&gt; folder and compile and then run the program. But I wanted more, because if we&apos;re creating this entire build system, we might as well make it more powerful.&lt;/p&gt;
&lt;p&gt;That brings us to &lt;code&gt;build.mar&lt;/code&gt;. When compiling, the &lt;code&gt;std&lt;/code&gt; library is always included, and then the &lt;code&gt;build&lt;/code&gt; function is called. The &lt;code&gt;std&lt;/code&gt; library exposes the &lt;code&gt;CompilationUnit&lt;/code&gt; type, an object that represents the current program&apos;s files and dependencies.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rs&quot;&gt;fn build() {
 var unit = CompilationUnit::new();
 unit.fetch(&amp;quot;somelib&amp;quot;, &amp;quot;https://some.other/library&amp;quot;);
 unit.import(&amp;quot;std/&amp;quot;);
 unit.build();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This version isn&apos;t final because it doesn&apos;t handle libraries having dependencies. My current idea is to change the build function&apos;s signature to &lt;code&gt;fn build(): CompilationUnit&lt;/code&gt;, letting libraries return their dependency info, allowing the creation of a single unit recursively.&lt;/p&gt;
&lt;p&gt;Side note, here&apos;s a funny thing I discovered while working on this. Since margarine can run with compiler errors, as long as you don&apos;t actually execute the errors, you can actually compile the current file with new libraries.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rs&quot;&gt;fn build() {
 var unit = CompilationUnit::new();
 unit.fetch(&amp;quot;rand&amp;quot;, &amp;quot;https://github.com/todaymare/margarine-rand&amp;quot;);
 unit.import(&amp;quot;&amp;quot;);
 unit.build()
}

fn main() {
   print(rand::rand())
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;which will work perfectly fine. Apart from spamming your terminal with compiler errors.&lt;/p&gt;
&lt;p&gt;Back to the build system, another thing I recently considered was to go with Go style imports. You know, just&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;extern &amp;quot;https://github.com/todaymare/margarine-std&amp;quot; as std
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;in the middle of the program. This would allow me to not have a build system, but I&apos;m not sure. I&apos;ll have to think more about this whole build system thing.&lt;/p&gt;
&lt;p&gt;It&apos;s kind of annoying to constantly be working on things that aren&apos;t guaranteed to be finished, so I just decided to quickly write up something that&apos;s very important and is pretty much as complete as I&apos;ll ever make it be&lt;/p&gt;
&lt;h2&gt;The GC&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;is garbage collection just a metaphor for letting go?&lt;br /&gt;
- William Shakespeare&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;We&apos;re coming to the end of the week and while I have experimented with a lot of things I wouldn&apos;t call those two complete just yet. However, the garbage collection for margarine is complete. It&apos;s definitely not the fastest or the most optimal but it does clean up garbage when needed so it&apos;s fine.&lt;/p&gt;
&lt;p&gt;What I did you might ask? I just copy-pasted the garbage collection I had for my old project &lt;a href=&quot;https://github.com/todaymare/azurite&quot;&gt;azurite&lt;/a&gt;. I know I know lame! It&apos;s just a basic mark &amp;amp; sweep world-stopping tracing garbage collector.&lt;/p&gt;
&lt;p&gt;There isn&apos;t much to say about it. It just goes through the stack, marks objects as live and then kills any that are dead. Oh and I guess it&apos;s only called when you fail to allocate an object.&lt;/p&gt;
&lt;h2&gt;End of the Week&lt;/h2&gt;
&lt;p&gt;Anyway, that&apos;s where margarine stands this week. A tiny bit more of a real boy.&lt;/p&gt;
&lt;p&gt;Thank you for reading so far and if you enjoyed this post or have feedback on any of the design decisions I talked above consider joining &lt;a href=&quot;https://discord.gg/t7gNX8Kp72&quot;&gt;my discord server&lt;/a&gt;, or you can e-mail me at &lt;a href=&quot;mailto:contact@daymare.net&quot;&gt;contact@daymare.net&lt;/a&gt;. Or if you really enjoyed it, consider &lt;a href=&quot;https://ko-fi.com/todaymare&quot;&gt;buying me a cup of coffee&lt;/a&gt;&lt;/p&gt;</content></entry><entry><title>Everybody&apos;s so Creative!</title><id>https://daymare.net/blogs/everbody-so-creative</id><updated>2025-10-19T08:39:24.740553972+00:00</updated><author><name>daymare</name><uri>https://daymare.net/</uri></author><category term="Blog"/><link href="https://daymare.net/blogs/everbody-so-creative" rel="alternate"/><published>2025-10-19T08:39:24.740553972+00:00</published><summary>&lt;p&gt;After 4 years with Rust, I love the language – but I’m starting to think the ecosystem has an abstraction addiction. Or: why every Rust crate feels like a research paper on abstraction.&lt;/p&gt;</summary><content type="html">&lt;p&gt;After 4 years with Rust, I love the language – but I’m starting to think the ecosystem has an abstraction addiction. Or: why every Rust crate feels like a research paper on abstraction.&lt;/p&gt;
&lt;p&gt;Hi, it’s me again. Back at it with another rant thinly disguised as a &amp;quot;think piece.&amp;quot;&lt;/p&gt;
&lt;h2&gt;The Question Nobody Wants to Answer&lt;/h2&gt;
&lt;p&gt;Have you ever wanted to build something simple in Rust?
Maybe you reach for &lt;code&gt;bevy&lt;/code&gt;, or &lt;code&gt;wgpu&lt;/code&gt;, or some other library that promises everything you didn&apos;t ask for.&lt;/p&gt;
&lt;p&gt;And then you hit that moment – you&apos;re debugging, you hit &amp;quot;Go to Definition&amp;quot;, and suddenly you&apos;re free falling through ten layers of traits, macros, and generics just to figure out how a buffer updates.&lt;/p&gt;
&lt;p&gt;If that sounds familiar, congratulations: you&apos;ve met Rust&apos;s favourite pastime – abstraction as performance art.&lt;/p&gt;
&lt;h2&gt;Why Are We Like This?&lt;/h2&gt;
&lt;p&gt;I get it – abstractions are cool. They’re supposed to hide complexity so we can focus on cooler stuff. And Rust loves that idea. Traits, generics, lifetimes – layer upon layer of &amp;quot;don’t worry about it honey.&amp;quot;&lt;/p&gt;
&lt;p&gt;Take &lt;code&gt;nalgebra&lt;/code&gt;. Fantastic crate – powerful, flexible, and deeply overqualified for 90% of use cases.&lt;/p&gt;
&lt;p&gt;It’s not that I hate nalgebra – it’s brilliant. I just hate that this kind of maximalism has become the default.&lt;/p&gt;
&lt;p&gt;Want to do something slightly off-script?&lt;br /&gt;
That’ll be three trait bounds, one custom derive, and a spiritual journey through &lt;code&gt;src/internal/utils/mod.rs&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;You might say these libraries are built this way because we don’t know what the user might want – and fair enough, that’s been the curse of library design since the dawn of libraries. But not every problem needs a skyscraper of abstractions; most of the time, all you need is a shed.&lt;/p&gt;
&lt;p&gt;Take &lt;code&gt;glam&lt;/code&gt;, for example, which doesn’t try to solve philosophy – it just does math. You don’t need a PhD in generics to understand what &lt;code&gt;Vec3::normalize()&lt;/code&gt; does, and that’s exactly the point.&lt;/p&gt;
&lt;p&gt;But the thing is – &lt;code&gt;nalgebra&lt;/code&gt; isn&apos;t an isolated example. It’s cultural.&lt;/p&gt;
&lt;p&gt;And that’s the real cost of abstraction – it makes the ceiling higher, but it also makes the floor invisible. (Shakespeare got nothin’ on me)&lt;/p&gt;
&lt;p&gt;The real tragedy? Once you see it, you start writing that way too.
You start thinking, &amp;quot;Well, maybe I should make this generic in case someone wants to use quaternions instead of matrices...&amp;quot; and suddenly, congratulations – you&apos;re building for someone who doesn&apos;t exist.&lt;/p&gt;
&lt;h2&gt;Rust, the Language&lt;/h2&gt;
&lt;p&gt;Rust is a great language. I’ll be the first to say that. It’s not perfect – no language is except &lt;a href=&quot;https://github.com/todaymare/margarine&quot;&gt;margarine&lt;/a&gt; – but it’s the tool I reach for first.&lt;/p&gt;
&lt;p&gt;That said, the Rust ecosystem feels like it&apos;s divided into two sides. (Ironic, isn’t it?)&lt;/p&gt;
&lt;p&gt;On one side, you’ve got artists. The folks who treat Rust like an art form – every crate is a masterpiece of generics, lifetimes, and zero-cost abstractions. They push the language to its limits, and honestly? It’s incredible to watch.&lt;/p&gt;
&lt;p&gt;On the other side are the people trying to ship things, the ones who’d use Zig if it weren’t allergic to syntactic sugar. They don’t care about elegance or clever abstractions – they just want their code to compile before they age into retirement.&lt;/p&gt;
&lt;p&gt;That phrasing sounds harsh, but the thing is: neither side is wrong.&lt;/p&gt;
&lt;p&gt;Let&apos;s get one thing straight: over-engineering in Rust is incredibly fun. The language hands you these shiny tools and it&apos;s hard not to play with them. It&apos;s like LEGO for programmers.&lt;/p&gt;
&lt;p&gt;And hey, when you can push the boundaries of abstractions and keep things fast? It feels like you&apos;ve cracked the code to the universe.&lt;/p&gt;
&lt;p&gt;But still; most people just want to see what the code does, not spelunk through an art installation of traits.&lt;/p&gt;
&lt;p&gt;The core problem is that Rust being Rust turns code you can’t understand into the default.
The community shows up to tell you that if you don’t over-complicate it, you’re writing unidiomatic Rust.&lt;/p&gt;
&lt;p&gt;If &amp;quot;Go to Definition&amp;quot; can’t take me to your implementation and I have to dig through your GitHub repo just to see how Matrix4::mul works – can I really say I know the code I’m using?&lt;/p&gt;
&lt;p&gt;For many people, maybe that’s fine. But every dependency you bring in is still your responsibility. Obviously I don’t understand every library I use – that’d be absurd – but I’d like to live in a world where I can understand the code I bring in.&lt;/p&gt;
&lt;p&gt;And just to be clear: abstraction isn’t the enemy. It’s what lets you write 3D engines or HTTP servers without caring about hardware or the TCP stack.
The problem is when we build for someday instead of today.&lt;/p&gt;
&lt;p&gt;I’m not saying stop writing clever code – just make sure it earns its keep. When you feel that &amp;quot;maybe I should make this generic&amp;quot; impulse, ask: Who benefits from this, today?
If the answer is &amp;quot;future me,&amp;quot; maybe wait until future you actually shows up.&lt;/p&gt;
&lt;p&gt;Here’s my rule of thumb: &lt;strong&gt;keep &amp;quot;Go to Definition&amp;quot; useful.&lt;/strong&gt;&lt;/p&gt;
&lt;h1&gt;The Conclusion&lt;/h1&gt;
&lt;p&gt;I&apos;ve been on both sides of the extreme. Heck, my first time trying to learn OpenGL I tried to write a compile-time zero-cost abstraction for it while I was learning it. Later, I just went with raw OpenGL in a dozen different projects.
So, yeah, I&apos;ve lived both sides of the story.&lt;/p&gt;
&lt;p&gt;From that experience, I&apos;ve learned one thing: things are almost always easier when there are fewer moving parts. Simpler code doesn&apos;t mean worse code – it just means you can still understand it six months later.&lt;/p&gt;
&lt;p&gt;So maybe try the other side of the spectrum if you haven&apos;t. Or don&apos;t.&lt;/p&gt;
&lt;p&gt;Anyway, this post will probably age terribly. Someone will send it to me in two years while I’m working on my eighth trait-based ECS library written entirely in macros.&lt;/p&gt;
&lt;p&gt;But for now, I just wanted to encourage maybe one person to try to write code that&apos;s just code... not abstracted, not filled with traits or generics... just code.&lt;/p&gt;
&lt;p&gt;Maybe one day the novelty will wear off, and Rust will chill out.&lt;/p&gt;
&lt;p&gt;Until then, I&apos;ll be over here using &lt;code&gt;glam&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If you enjoyed this post, I&apos;d love it if you could whisper &apos;nice post&apos; at your screen... &lt;a href=&quot;https://ko-fi.com/todaymare&quot;&gt;or drop me a coffee&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;P.S grammarly forked me over vro 🥀&lt;/p&gt;</content></entry><entry><title>Godot Ruined My Sense of Speed</title><id>https://daymare.net/blogs/godot-ruined-me</id><updated>2025-10-12T21:09:01.870614127+00:00</updated><author><name>daymare</name><uri>https://daymare.net/</uri></author><category term="Blog"/><link href="https://daymare.net/blogs/godot-ruined-me" rel="alternate"/><published>2025-10-12T21:09:01.870614127+00:00</published><summary>&lt;p&gt;Godot didn’t just ruin my game. It ruined how I think about performance and abstraction. What started as a simple voxel prototype spiraled into an existential crisis&lt;/p&gt;</summary><content type="html">&lt;p&gt;Godot didn’t just ruin my game. It ruined how I think about performance and abstraction. What started as a simple voxel prototype spiraled into an existential crisis&lt;/p&gt;
&lt;p&gt;It was a sunny day (probably), a few months back. I was in a hotel room on my laptop – the one I definitely bought for studying – playing Factorio, like any good student does.
And then I had a brilliant idea.
An automation game.
Factorio, but bigger! And better!&lt;/p&gt;
&lt;p&gt;Did it matter that I had no experience making games?
Don&apos;t be ridiculous, of course not!&lt;/p&gt;
&lt;p&gt;The plan: mix Factorio’s automation, Terraria’s boss fights, and a Minecraft-esque voxel world.
So I said, considering I have no graphics development experience I should start simple – and make a voxel engine&lt;/p&gt;
&lt;h2&gt;The Prototype&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;All good games need a prototype&lt;br /&gt;
- Sun Tzu&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Naturally, the next step was to pick an engine.&lt;br /&gt;
I wanted something fast, simple, cross-platform – and preferably not Unity, because, well, Unity.&lt;/p&gt;
&lt;p&gt;Godot seemed perfect. Lightweight, open source, recently got a shiny new 3D renderer (and also because UE hates MacOS)&lt;/p&gt;
&lt;p&gt;Of course, I knew GDScript wasn&apos;t going to survive a voxel world. So I wrote the simulation in Rust and used Godot purely for visuals.&lt;br /&gt;
Simple plan, what could possibly go wrong?&lt;/p&gt;
&lt;p&gt;So I started.&lt;br /&gt;
Made a Rust extension. Drew a quad. Then a cube. Then a whole chunk.&lt;br /&gt;
Suddenly I had mining. Machines. Inserters. Belts. Quarries. Crafting.&lt;/p&gt;
&lt;p&gt;I was unstoppable running purely on caffeine and motivation.&lt;br /&gt;
It might sound like I&apos;m glossing over the implementation, but the entire prototype took literally two days.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daymare.net/blogs/godot-ruined-me/assets/prototype.png&quot; alt=&quot;An image of the prototype&quot; /&gt;&lt;/p&gt;
&lt;p&gt;I had so many conversations about how the quarry should work with my friends. It was an interesting design problem: finding upgrades for quarries that weren&apos;t just &amp;quot;the same thing, but faster&amp;quot;, especially since the quarries were meant to dig into the world and destroy it.&lt;/p&gt;
&lt;p&gt;That also turned quarries into a single-pipe problem — where common resources clog the system and starve rarer ones. Totally irrelevant for this prototype though, since items were just physics bodies moving on top of belts.&lt;/p&gt;
&lt;p&gt;Anyways, I was ready. I had spent roughly 32 hours over 2 days working on the first prototype of my life. I went outside to grab some food, came back, and even arranged a play-test for the next day.&lt;/p&gt;
&lt;p&gt;Everything was perfect.&lt;br /&gt;
The engine worked. The game ran smoothly – until it didn&apos;t.&lt;/p&gt;
&lt;h3&gt;Things go VERY WRONG&lt;/h3&gt;
&lt;p&gt;Look, I&apos;m lucky enough to have a great computer. During my testing I couldn&apos;t even get the game to go below 144FPS.&lt;br /&gt;
But see, I never tried throwing more quarries at it because I assumed any slow-down would come from the naturally expensive thing – the rigidbodies that I used for items.&lt;/p&gt;
&lt;p&gt;In order for this to make sense I need to show you how procedurally generating a chunk goes in Godot.&lt;/p&gt;
&lt;p&gt;A chunk is just a mesh made of triangles made of vertices.
In the simplest voxel engines, you’d generate a quad for every block face — slow, but simple.
For the prototype, I added a very naive culling algorithm so it wouldn’t generate hidden faces.&lt;/p&gt;
&lt;p&gt;So far so good. This entire algorithm was implemented in Rust (&lt;em&gt;blazing fast!&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;Godot exposes a type called &lt;a href=&quot;https://docs.godotengine.org/en/stable/classes/class_surfacetool.html&quot;&gt;SurfaceTool&lt;/a&gt;, which isn&apos;t technically the lowest-level API they provide but it is pretty much a drop-in replacement for pushing individual vertices into a list.&lt;/p&gt;
&lt;p&gt;Anyway, here’s how that looked in code – calling into Godot from Rust, in order to draw a quad:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;fn draw_quad(st: &amp;amp;mut SurfaceTool, k: &amp;amp;mut i32, quad: Quad) {
    let normal = match quad.direction {
        ...
    };

    st.set_color(quad.color);
    st.set_normal(normal);
    for corner in quad.corners {
        st.add_vertex(corner);
    }


    st.add_index(*k);
    st.add_index(*k + 1);
    st.add_index(*k + 2);
    st.add_index(*k + 2);
    st.add_index(*k + 3);
    st.add_index(*k);

    *k += 4;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And here’s what “just pushing to a list” looks like in comparison:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;fn draw_quad(vertices: &amp;amp;mut Vec&amp;lt;Vector3&amp;gt;, indices: &amp;amp;mut Vec&amp;lt;i32&amp;gt;, k: &amp;amp;mut i32, quad: Quad) {
    let normal = match quad.direction {
        ...
    };

    for corner in quad.corners {
        vertices.push(corner);
    }


    indices.push(*k);
    indices.push(*k + 1);
    indices.push(*k + 2);
    indices.push(*k + 2);
    indices.push(*k + 3);
    indices.push(*k);

    *k += 4;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You might notice there’s not much difference, so really, how bad could &lt;a href=&quot;https://docs.godotengine.org/en/stable/classes/class_surfacetool.html&quot;&gt;SurfaceTool&lt;/a&gt; be?&lt;/p&gt;
&lt;p&gt;8 milliseconds per chunk! Not terrible – until you realize doing it manually takes 300 microseconds. Twenty-seven times faster.&lt;/p&gt;
&lt;p&gt;And that’s not even counting Godot’s mesh conversion time, which I’m pretty sure happens way later.&lt;/p&gt;
&lt;p&gt;At this point you can probably guess what went wrong.
When my friend play-tested the game, the framerate dropped to a cinematic 10 FPS within an hour.&lt;/p&gt;
&lt;p&gt;Why didn&apos;t I notice it during my own testing?
Simple, I was doing things efficiently. I already knew what to build, nothing went to waste.&lt;br /&gt;
He, on the other hand, decided to cover the planet in quarries (like, five quarries).&lt;/p&gt;
&lt;p&gt;After it dropped to 10 FPS, he stopped playing. Which, fair.&lt;br /&gt;
I still count an hour-long playtest as a win – but the reason he stopped playing was... traumatizing.&lt;/p&gt;
&lt;h1&gt;The Rebound&lt;/h1&gt;
&lt;p&gt;The prototype was a success, somewhat.&lt;br /&gt;
So now it was time to make the actual game, properly this time.&lt;/p&gt;
&lt;p&gt;After that Godot fiasco I decided I&apos;d just go pure Rust.&lt;/p&gt;
&lt;p&gt;But you can&apos;t just start a project, you need an engine!
And it needs to be super performant because I never want to see someone stop playing because of performance again.&lt;/p&gt;
&lt;p&gt;Okay, calm down champ.&lt;/p&gt;
&lt;p&gt;After the Godot incident (yes, I&apos;m going to call it that, fight me) I over-corrected hard in the other direction to the point where I was seriously considering making a full-blown game engine.&lt;br /&gt;
Which, granted, isn&apos;t entirely out of the question for me... but still, absurdly unnecessary.&lt;/p&gt;
&lt;p&gt;Eventually, a brick hit my head and I realized I could just... make a game.
No engine. No framework. Just raw OpenGL and a giant while loop.&lt;/p&gt;
&lt;p&gt;Of course you don&apos;t need fancy frameworks or giant game engines... You can just make a game.&lt;/p&gt;
&lt;p&gt;At the time, however, this was a big revelation for me.&lt;/p&gt;
&lt;p&gt;So I opened up LearnOpenGL and started replicating my Godot voxel engine one-to-one. Which was quite easy, considering I had to do everything manually anyway.&lt;br /&gt;
I had a pretty good voxel engine by this point, it was so much faster than Godot could&apos;ve ever been, but now I had to actually implement game features.&lt;/p&gt;
&lt;p&gt;The first of many being machines.&lt;/p&gt;
&lt;p&gt;You see in games like Factorio many machines don&apos;t need to always run. In fact, they don&apos;t! Most machines take in some sort of input, process it for N frames, and then do something as a result of it.&lt;br /&gt;
This sort of system lands itself very well to a WorkQueue.&lt;/p&gt;
&lt;p&gt;Basically, whenever a machine needed to do something again in 20 ticks it would tell the WorkQueue &amp;quot;hmu in 20 ticks&amp;quot; and then the WorkQueue would handle that accordingly.&lt;br /&gt;
This system made sure that even if you had millions of machines only the ones that needed to be updated this tick would be accessed.&lt;/p&gt;
&lt;p&gt;Then, came the belts. In Godot I used physics bodies for items on belts because that was the easiest way to do so but it came with a lot of cons the biggest of which being the fact that belts had no throughput limit. Which cuts out basically 80% of the puzzle in automation games.&lt;/p&gt;
&lt;p&gt;The tricky part about Factorio-style belts is that they need to be updated back to front, so I had to figure out which belts depend on which other belts – a mini dependency graph!&lt;br /&gt;
Now, after coming from Godot my perception of performance was so ruined that I was incredibly worried that this was going to be a major performance bottleneck if I didn&apos;t aggressively cache it.&lt;/p&gt;
&lt;p&gt;Luckily for me, I am not skilled enough to be able to write an algorithm that&apos;s able to heavily cache it so I decided to settle for just reconstructing the entire graph every frame. And guess what? It never became a performance problem.&lt;/p&gt;
&lt;p&gt;Well that was simple enough, I&apos;ll also mention the things that happened after all of that.&lt;br /&gt;
I went on a 3 week journey to optimize the heck out of the voxel engine, during which I switched from OpenGL to WGPU because OpenGL on MacOS does not support Shader Storage Buffer Objects (SSBOs)&lt;/p&gt;
&lt;p&gt;I might make a post on how I optimized the voxel engine (&lt;a href=&quot;https://www.youtube.com/watch?v=40JzyaOYJeY&quot;&gt;check out this video by Vercidium&lt;/a&gt;) but by the end of it I had a voxel engine with async chunk &amp;amp; mesh generation, running at 144FPS+ on an M2 MacBook using 3 GB of ram with a render distance of 3072 blocks in every direction.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daymare.net/blogs/godot-ruined-me/assets/voxel-engine.png&quot; alt=&quot;Voxel Engine Picture&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;The conclusion?&lt;/h1&gt;
&lt;p&gt;I can&apos;t say this story has a very good conclusion because the game never ended up getting finished. Mostly because I couldn&apos;t figure out a way to make a factory game feel nice to play in a 3D voxel sandbox.&lt;/p&gt;
&lt;p&gt;What I learned from all this wasn’t really about Godot or performance – it was about trust. Or the lack of it.&lt;/p&gt;
&lt;p&gt;I thought I was writing about slow code, but looking back, I was really writing about black boxes I couldn’t see inside.&lt;/p&gt;
&lt;p&gt;After going cold-turkey on abstractions, I realized something worse than inefficiency: bloat. It turns out working in a simple, honest codebase – one where you see everything – is just more fun.&lt;/p&gt;
&lt;p&gt;For those who may want to check out the source code for the final version of the game &lt;a href=&quot;https://github.com/todaymare/factory-game&quot;&gt;here you go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Maybe there&apos;s a conclusion to draw from this story, in any case I hope you enjoyed it. And if you did, consider &lt;a href=&quot;https://ko-fi.com/todaymare&quot;&gt;buying me a cup of coffee&lt;/a&gt;&lt;/p&gt;</content></entry><entry><title>Four years, Five failures, One compiler</title><id>https://daymare.net/blogs/four-years-five-failures-one-compiler</id><updated>2025-10-05T14:36:34.509273115+00:00</updated><author><name>daymare</name><uri>https://daymare.net/</uri></author><category term="Blog"/><link href="https://daymare.net/blogs/four-years-five-failures-one-compiler" rel="alternate"/><published>2025-10-05T14:36:34.509273115+00:00</published><summary>&lt;p&gt;At 14, I thought writing a compiler would be a quick side quest in building a game engine. Four years later, I finally built one that works. And it was one hell of a journey.&lt;/p&gt;</summary><content type="html">&lt;p&gt;At 14, I thought writing a compiler would be a quick side quest in building a game engine. Four years later, I finally built one that works. And it was one hell of a journey.&lt;/p&gt;
&lt;p&gt;Before I dive into the compilers themselves, I should explain why I even started making them in the first place. Initially, writing a programming language wasn&apos;t the goal; it was just supposed to be a small part of a bigger piece: building my own game engine. I didn&apos;t expect that &amp;quot;small part&amp;quot; to turn into a four-year rabbit hole, but now that you know why it all started, let&apos;s look at a few of the failed projects, shall we?&lt;/p&gt;
&lt;h2&gt;CryScript&lt;/h2&gt;
&lt;p&gt;Super edgy name, I know. To be fair, the game engine this was meant for was called &lt;em&gt;Crytex&lt;/em&gt;, so that doesn&apos;t make it any better. It was back in early 2022, so technically, the title of this post is clickbait. Oh well.&lt;/p&gt;
&lt;p&gt;While writing this, I dug through &lt;a href=&quot;https://github.com/todaymare/CryScript/&quot;&gt;the old GitHub repo&lt;/a&gt;, which had a very odd structure. Something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;crates/
 cry_script/
 src/
        ..
    Cargo.toml
src/
 main.rs
Cargo.toml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I have no idea what I was on when I set it up like that, but for a moment, it actually scared me. I thought I&apos;d lost the source. Luckily, the code&apos;s all still there, so let&apos;s take a look and have some fun.&lt;/p&gt;
&lt;p&gt;I&apos;m pretty sure I started off by following a &lt;a href=&quot;https://www.youtube.com/watch?v=Eythq9848Fg&amp;amp;list=PLZQftyCk7_SdoVexSmwy_tBgs7P0b97yD&quot;&gt;Python compiler tutorial&lt;/a&gt;... in Rust.&lt;/p&gt;
&lt;p&gt;And surprisingly, that worked well for the first half. I got the lexer and parser running (basically the parts that read the code), and they still hold up well even now.&lt;/p&gt;
&lt;p&gt;However, things started falling apart once I reached the interpreter, the bit that&apos;s supposed to run the code.&lt;/p&gt;
&lt;p&gt;But up until that point? Honestly, not bad. Even skimming through it today, I can see the same patterns I still use in my work.&lt;/p&gt;
&lt;p&gt;..Oh my god, I take all of that back.&lt;br /&gt;
The interpreter is an abomination of Rust code, and it&apos;s also where you can clearly see the effects of Python. It&apos;s a tree-walk interpreter, which basically means the Rust compiler absolutely hates it.&lt;/p&gt;
&lt;p&gt;I vividly remember fighting the borrow checker &amp;amp; sprinkling in `Rc&amp;lt;RefCell&amp;lt;_&amp;gt;&amp;gt;&apos;s everywhere whilst writing this, and it seems like eventually, I just gave up and resorted to doing:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;struct VariableReference {
 reference: *mut Variable,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which is, apparently, a non-clone, manual version of a reference-counted value?&lt;br /&gt;
Not a clue who wrote that code; definitely wasn&apos;t me!&lt;br /&gt;
For non-Rust users: this is me fighting the language&apos;s safety system and losing badly.&lt;/p&gt;
&lt;p&gt;I have no idea where this was needed, but it might be one of the worst pieces of Rust code I&apos;ve ever written, second only to the &lt;em&gt;Crytex&lt;/em&gt; engine.&lt;/p&gt;
&lt;p&gt;That one doesn&apos;t even compile anymore, by the way, because newer Rust versions prevent casting an immutable reference to a mutable one. (Which, fun fact, is undefined behaviour)&lt;/p&gt;
&lt;p&gt;Oh, and apparently, I was passing around the main context of the interpreter as a mutable pointer. Those of you who use languages like C or C++ might think &amp;quot;so what? that&apos;s normal&amp;quot;, but in Rust, using pointers mixed with references comes with quite a bit more headache.&lt;/p&gt;
&lt;p&gt;In hindsight, &lt;em&gt;CryScript&lt;/em&gt; was less of a compiler and more of a Rust safety demonstration. The fact that it even ran code at all is a miracle. If I pulled this at a Rust conference, I&apos;d probably get banned. But it was a Rust newbie&apos;s first attempt at making a compiler, and it wasn&apos;t a half-bad one.&lt;/p&gt;
&lt;h2&gt;azurite&lt;/h2&gt;
&lt;p&gt;Fast forward a year, and I started making &lt;em&gt;azurite&lt;/em&gt; (the &apos;a&apos; is non-capitalised intentionally). This one&apos;s very near and dear to my heart as it&apos;s the project that let me meet some amazing people I still talk to today.&lt;/p&gt;
&lt;p&gt;Unlike &lt;em&gt;CryScript&lt;/em&gt;, this one came a bit later, when I actually knew how to use GitHub. It has 76 commits, many of which have completely nonsensical names that could probably get me rejected from a few jobs.&lt;/p&gt;
&lt;p&gt;I should, however, mention that between starting &lt;em&gt;azurite&lt;/em&gt; and finishing &lt;em&gt;CryScript&lt;/em&gt;, I joined the r/ProgrammingLanguage&apos;s Discord server, which led to me reading the book &lt;a href=&quot;https://craftinginterpreters.com/&quot;&gt;Crafting Interpreters&lt;/a&gt;. I think everyone interested in compilers or interpreters should go through it at least once.&lt;/p&gt;
&lt;p&gt;Unfortunately, I don&apos;t actually know when &lt;em&gt;azurite&lt;/em&gt; started, since the GitHub repo seems to have been created after the language was already up and running. There are a bunch of example programs and documentation in there, so it must&apos;ve been pretty far along.&lt;/p&gt;
&lt;p&gt;There are binaries uploaded from the early days, but since I apparently thought my code was too special to share, I didn&apos;t upload the source, you know, in case someone stole my brainchild. After a while, though, I came to my senses, uploaded the code, and blessed the world with my amazing engineering.&lt;/p&gt;
&lt;p&gt;A significant difference between &lt;em&gt;azurite&lt;/em&gt; and &lt;em&gt;CryScript&lt;/em&gt; is that &lt;em&gt;azurite&lt;/em&gt; actually had static analysis, whereas &lt;em&gt;CryScript&lt;/em&gt; was dynamically-typed. That said, the lexer and the parser are almost identical.&lt;/p&gt;
&lt;p&gt;I&apos;d love to make fun of the static analysis, but honestly, many of the core ideas I used back then are still part of how I think about language design today. It&apos;s surprising to see that, at least on a high level, I already had a so-so grasp of the basics.&lt;/p&gt;
&lt;p&gt;But I did find this comment, which I think perfectly captures my ambition at the time.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// TODO: Maybe make the multi-file-loading multi-threaded
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The bytecode interpreter for &lt;em&gt;azurite&lt;/em&gt; had a major performance flaw that someone else figured out. If I remember correctly, it was something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;let mut callstack = ..
let mut code = &amp;amp;mut callstack[0];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;vs&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;let mut code = callstack[0].clone();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That one change made the interpreter run &lt;strong&gt;10x faster&lt;/strong&gt;. Wild. But more importantly, that flaw introduced me to &lt;a href=&quot;https://www.youtube.com/@leddoo&quot;&gt;leddoo&lt;/a&gt;, who&apos;s now a close friend. So I guess being bad at programming has its perks.&lt;/p&gt;
&lt;p&gt;I also noticed other people starring and contributing to this project, which might make you wonder why I stopped working on it. The reason is quite simple really, the codebase collapsed under its own weight.&lt;/p&gt;
&lt;p&gt;See, that&apos;s the problem with making a long-term project in a field you barely understand. Every time you add something that wasn&apos;t initially expected, in my case that was generics, the codebase just gets worse and worse and eventually it got too much to handle.&lt;/p&gt;
&lt;p&gt;It&apos;s bittersweet reading the old commit log. People added features like a REPL — that one was my now-friend &lt;a href=&quot;https://github.com/pyrotek45/&quot;&gt;Pyrotek45&lt;/a&gt; — and then months later, I removed it. To anyone who ever contributed to &lt;em&gt;azurite&lt;/em&gt; and happens to read this: thank you. I really mean it.&lt;/p&gt;
&lt;h2&gt;margarine&lt;/h2&gt;
&lt;p&gt;And now the final gauntlet. &lt;em&gt;margarine&lt;/em&gt;.&lt;br /&gt;
I started near the end of 2023. At first, it was supposed to be for another game engine, this one called &lt;em&gt;butter&lt;/em&gt;. The plan was to make a language centred around ECS architecture and value types. I even wrote a lexer, parser, semantic analysis, and an LLVM-based codegen.&lt;/p&gt;
&lt;p&gt;But when it came to integrating it, I caved and just used Lua. Yeah. Because here&apos;s the truth: I&apos;d spent four years learning how to make a compiler... but not how to make a game engine.&lt;/p&gt;
&lt;p&gt;That actually felt horrible. After all that work, I shelved margarine. I moved on to voxel engines, games, raytracers, fluid simulations and much more..&lt;/p&gt;
&lt;p&gt;You read the title, though, you know the story didn&apos;t end there.&lt;/p&gt;
&lt;p&gt;A couple of weeks ago, I came back to &lt;em&gt;margarine&lt;/em&gt;, for what reason I don&apos;t know. This time, I stripped away the over-engineering (no more ECS gimmick). I ditched LLVM (way too painful) and built a clean bytecode interpreter instead.&lt;/p&gt;
&lt;p&gt;And now? I finally have what I dreamed of: an embeddable programming language I can use in any project.&lt;/p&gt;
&lt;p&gt;So here it is, after years of broken interpreters, pointer hacks, and abandoned repos, I am delighted to introduce to you, &lt;em&gt;margarine&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;fn main() {
 var numbers = [1, 2, 3, 4, 5]
 var multiplier = int::parse(std::read()!)!

 var doubled = numbers.map(|n| n * multiplier)
    print(doubled)
    // If input is 2 → [2, 4, 6, 8, 10]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A language that feels like Rust, but without the fights I used to lose with the borrow checker. It&apos;s a statically-typed language that is almost too trivial to embed into any project. The syntax is very akin to Rust with Iterators, Closures, and much more!&lt;/p&gt;
&lt;p&gt;Was this post just a big ad for &lt;em&gt;margarine&lt;/em&gt;? It certainly wasn&apos;t the intention but after four years it feels good to finally share something that works, and it couldn&apos;t hurt to &lt;a href=&quot;https://github.com/todaymare/margarine&quot;&gt;check it out&lt;/a&gt; can it?&lt;/p&gt;
&lt;p&gt;and hey, if it resonated with you &lt;a href=&quot;https://ko-fi.com/todaymare&quot;&gt;consider dropping me a coffee&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;PS: I’ve seen a few people mention they’d have liked a more technical deep dive, totally fair. This post was always meant as a story of the journey, not the implementation, but don’t worry: a detailed, technical write-up is already in the works. Thanks to everyone who read and shared feedback, seriously appreciate it.&lt;/p&gt;</content></entry><entry><title>hello world</title><id>https://daymare.net/blogs/first-blog</id><updated>2025-10-02T19:36:48.068611622+00:00</updated><author><name>daymare</name><uri>https://daymare.net/</uri></author><category term="Blog"/><link href="https://daymare.net/blogs/first-blog" rel="alternate"/><published>2025-10-02T19:36:48.068611622+00:00</published><summary>&lt;p&gt;uh, hi, idk what to say here but helloooo. i made a static site generator for this. it takes the first line of the markdown as the title and the 2nd line as the summary actually i lied you can use multiple lines if you end the line with a \&lt;/p&gt;</summary><content type="html">&lt;p&gt;uh, hi, idk what to say here but helloooo. i made a static site generator for this. &lt;br /&gt;
it takes the first line of the markdown as the title and the 2nd line as the summary &lt;br /&gt;
actually i lied you can use multiple lines if you end the line with a \&lt;/p&gt;
&lt;p&gt;um, i&apos;m gonna ask chatgpt to write something here&lt;br /&gt;
it generated something super corny as expected. i ain&apos;t putting that in here&lt;/p&gt;
</content></entry></feed>